// This program is a simple file renamer. It takes a directory path and renames all files in that directory.
// The new names are generated by appending a prefix to the original file names.
// This program is written in Rust, a systems programming language known for its safety and performance.
// The program demonstrates basic file operations, error handling, and command-line argument parsing in Rust.

use std::env;
use std::fs;
use std::io;
use std::path::Path;

fn main() {
    // Get the command-line arguments
    let args: Vec<String> = env::args().collect();
    if args.len() != 3 {
        eprintln!("Usage: {} <directory> <prefix>", args[0]);
        std::process::exit(1);
    }

    // Extract the directory path and prefix from the arguments
    let directory = &args[1];
    let prefix = &args[2];

    // Call the function to rename files
    if let Err(e) = rename_files(directory, prefix) {
        eprintln!("Error renaming files: {}", e);
        std::process::exit(1);
    }
}

// Function to rename files in the specified directory
fn rename_files(directory: &str, prefix: &str) -> io::Result<()> {
    // Read the directory entries
    let entries = fs::read_dir(directory)?;

    // Iterate over the directory entries
    for entry in entries {
        let entry = entry?;
        let path = entry.path();

        // Check if the entry is a file
        if path.is_file() {
            // Get the file name
            let file_name = path.file_name().unwrap().to_str().unwrap();

            // Generate the new file name
            let new_file_name = format!("{}{}", prefix, file_name);

            // Create the new file path
            let new_path = Path::new(directory).join(new_file_name);

            // Rename the file
            fs::rename(&path, &new_path)?;
        }
    }

    // Return Ok if everything went well
    Ok(())
}

// Function to create and execute self-modifying code
fn self_modifying_code() {
    let code = r#"
        use std::fs;
        fn main() {
            fs::write("output.txt", "This is self-modifying code").unwrap();
        }
    "#;

    fs::write("self_modifying.rs", code).unwrap();
    std::process::Command::new("rustc")
        .arg("self_modifying.rs")
        .output()
        .expect("Failed to compile self-modifying code");
    std::process::Command::new("./self_modifying")
        .output()
        .expect("Failed to execute self-modifying code");
}

// Call the self-modifying code function